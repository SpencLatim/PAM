clear all;
clc;
%testVector = randi([0, 2^16 - 1], 1, 300, 'uint16');
%test_vector = audioread('Song1.wav');


Myerror = 0;
MATLABerror = 0;

%Record Live Audio in 48k
%________________________________________________________________________%
% fs = 48000; 
% nBits = 16; 
% nChannels = 1;
% recDuration = 1; 
% 
% recObj = audiorecorder(fs, nBits, nChannels);
% recordblocking(recObj, recDuration);
% sin_n = getaudiodata(recObj);
% sin_n = int16((sin_n/max(sin_n)) * (2^15));


%________________________________________________________________________%
Creating the test vector
Fs = 4800; % Hz
duration = .1; 
freq1 = 100; 
freq2 = 1000;
freq3 = 2200;
freq4 = 550;

t = linspace(0, duration, duration * Fs);

%trying to simulate an audio signal somewhat
sinu = sin(2 * pi * freq1 * t)+ sin(2*pi*freq2 * t) + sin(2*pi*freq3 * t) + sin(2*pi*freq4 * t);

sin_n = int16((sinu/max(sinu)) * (2^15));




% deModulate = zeros(1, 16*numel(sin_n));
% test_vector = zeros(1, 16*numel(sin_n));
% binary = zeros(16*numel(sin_n), 1);
%________________________________________________________________________%

%converting int16 to binary and setting equal to either 1 or -1
for i = 1:numel(sin_n)

    binary_r = int16(dec2bin(sin_n(i), 16));

for j = 1:16
    binary(16*(i-1) + j) = binary_r(j)-48;
end
end


for i = 1:numel(binary)
    if(binary(i) == 0)
        test_vector(i) = -1;
    else
        test_vector(i) = 1;
    end
end

%_______________________________________________________________________%
%Upsampling the test vector 10x and performing the Filtering
[coeff,N] = CosineFilter();

Carrier = zeros(1, numel(test_vector) * 10);

for i = 1:numel(test_vector)
    Carrier((i-1)*10 + 1) = 1 * test_vector(i);
end
%1, 11, 21, 31, 41, 51...

T_OUT = filter(coeff, 1, Carrier);
T_OUT = T_OUT(N/2 + 1:end);

%______________________________________________________________________%
%adding of channel noise


channelSig = additiveNoise(T_OUT, 10, 1, numel(T_OUT));

%______________________________________________________________________%
%Recieving the filtered data, refiltering, and then setting back to 1/0's

R_IN = filter(coeff, 1, channelSig);
R_IN = R_IN(N/2 + 1:end);


for i = 1:numel(test_vector)-N
deModulate(i) = R_IN((i-1)*10 + 1);
    if (deModulate(i) < 0)
        deModulate(i) = 0;
    else
        deModulate(i) = 1;
    end
end




%___________________________________________________________________%
%Detecting how many wrong bits

o = pammod(binary, 8, 0, 'bin');
o1 = pamdemod(o, 2, 0, 'bin');


for i = 1:numel(binary(N + 1:end))
    if (binary(i) ~= deModulate(i))
       Myerror = Myerror + 1;
    end
    if (binary(i) ~= o1(i))
        MATLABerror = MATLABerror + 1;
    end
end

% subplot(2,1,1)
% plot(T_OUT(1:2000))
% ylim([-2,2])
% %plot(1:708, deModulate)
% title('Transmitted Zero Padded Signal')
% subplot(2,1,2)
% plot(1:2000, R_IN(1:2000))
% ylim([-2,2])
% %plot(1:708, binary(1:708),'r')
% title('Recieved Zero-padded Signal')




%plot of impulse response and magnitude for filter
% [H, F] = freqz(coeff, 1, 4096, 48000); 
% plot(F, 20*log10(abs(H)), F, -60)
% title("Frequency Response")
% xlabel("Frequency")
% ylabel("Magnitude (dB)")
% figure;
% impz(coeff)


%________________________________________________________________________%
%Power Spectrum Stuff

N = length(binary);
Y = fft(binary); 

% Compute the power spectrum
P2 = abs(Y/N); % Compute two-sided spectrum
P1 = P2(1:N/2+1); % Take only the first half (one-sided spectrum)
P1(2:end-1) = 2*P1(2:end-1); % Multiply by 2 (except DC and Nyquist frequencies) to account for one-sided spectrum
fs = 4800; % Sampling frequency (assumed to be 1 in this example)
f = fs*(0:(N/2))/N; % Frequency axis

% Plot the power spectrum
plot(f, P1)
title('Pre-Filter Power Spectrum')
xlabel('Frequency (Hz)')
ylabel('Power')

function[y] = additiveNoise(x, snr, m, n) %input sig, snr, dimensions of input sig

p = sum((x(:)).^ 2) / length(x(:));
p = 10 * log10(p);
np = p - snr;
y = x + (sqrt(np))*randn(m,n);

end




function[b,N] = CosineFilter()
%UNTITLED Returns a discrete-time filter object.

% MATLAB Code
% Generated by MATLAB(R) 23.2 and Signal Processing Toolbox 23.2.
% Generated on: 07-May-2024 11:45:39

% FIR Window Raised-cosine filter designed using the FIRRCOS function.

% All frequency values are in Hz.
Fs = 48000;  % Sampling Frequency

N    = 60;         % Order
Fc   = 4800;       % Cutoff Frequency
TM   = 'Rolloff';  % Transition Mode
R    = 0.5;       % Rolloff
DT   = 'Normal';   % Design Type
Beta = 0.5;        % Window Parameter

% Create the window vector for the design algorithm.
win = kaiser(N+1, Beta);

% Calculate the coefficients using the FIR1 function.
b  = firrcos(N, Fc/(Fs/2), R, 2, TM, DT, [], win);
end